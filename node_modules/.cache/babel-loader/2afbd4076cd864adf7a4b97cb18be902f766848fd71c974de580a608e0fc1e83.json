{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { KEY_PREFIX } from './constants';\nexport default function createPersistoid(config) {\n  // defaults\n  const blacklist = config.blacklist || null;\n  const whitelist = config.whitelist || null;\n  const transforms = config.transforms || [];\n  const throttle = config.throttle || 0;\n  const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX}${config.key}`;\n  const storage = config.storage;\n  let serialize;\n  if (config.serialize === false) {\n    serialize = x => x;\n  } else if (typeof config.serialize === 'function') {\n    serialize = config.serialize;\n  } else {\n    serialize = defaultSerialize;\n  }\n  const writeFailHandler = config.writeFailHandler || null;\n  // initialize stateful values\n  let lastState = {};\n  const stagedState = {};\n  const keysToProcess = [];\n  let timeIterator = null;\n  let writePromise = null;\n  const update = state => {\n    // add any changed keys to the queue\n    Object.keys(state).forEach(key => {\n      if (!passWhitelistBlacklist(key)) return; // is keyspace ignored? noop\n      if (lastState[key] === state[key]) return; // value unchanged? noop\n      if (keysToProcess.indexOf(key) !== -1) return; // is key already queued? noop\n      keysToProcess.push(key); // add key to queue\n    });\n    //if any key is missing in the new state which was present in the lastState,\n    //add it for processing too\n    Object.keys(lastState).forEach(key => {\n      if (state[key] === undefined && passWhitelistBlacklist(key) && keysToProcess.indexOf(key) === -1 && lastState[key] !== undefined) {\n        keysToProcess.push(key);\n      }\n    });\n    // start the time iterator if not running (read: throttle)\n    if (timeIterator === null) {\n      timeIterator = setInterval(processNextKey, throttle);\n    }\n    lastState = state;\n  };\n  function processNextKey() {\n    if (keysToProcess.length === 0) {\n      if (timeIterator) clearInterval(timeIterator);\n      timeIterator = null;\n      return;\n    }\n    const key = keysToProcess.shift();\n    if (key === undefined) {\n      return;\n    }\n    const endState = transforms.reduce((subState, transformer) => {\n      return transformer.in(subState, key, lastState);\n    }, lastState[key]);\n    if (endState !== undefined) {\n      try {\n        stagedState[key] = serialize(endState);\n      } catch (err) {\n        console.error('reduxjs-toolkit-persist/createPersistoid: error serializing state', err);\n      }\n    } else {\n      //if the endState is undefined, no need to persist the existing serialized content\n      delete stagedState[key];\n    }\n    if (keysToProcess.length === 0) {\n      writeStagedState();\n    }\n  }\n  function writeStagedState() {\n    // cleanup any removed keys just before write.\n    Object.keys(stagedState).forEach(key => {\n      if (lastState[key] === undefined) {\n        delete stagedState[key];\n      }\n    });\n    writePromise = storage.setItem(storageKey, serialize(stagedState)).catch(onWriteFail);\n  }\n  function passWhitelistBlacklist(key) {\n    if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist') return false;\n    if (blacklist && blacklist.indexOf(key) !== -1) return false;\n    return true;\n  }\n  function onWriteFail(err) {\n    // @TODO add fail handlers (typically storage full)\n    if (writeFailHandler) writeFailHandler(err);\n    if (err && process.env.NODE_ENV !== 'production') {\n      console.error('Error storing data', err);\n    }\n  }\n  const flush = () => {\n    while (keysToProcess.length !== 0) {\n      processNextKey();\n    }\n    return writePromise || Promise.resolve();\n  };\n  // return `persistoid`\n  return {\n    update,\n    flush\n  };\n}\n// @NOTE in the future this may be exposed via config\nfunction defaultSerialize(data) {\n  return JSON.stringify(data);\n}","map":{"version":3,"names":["KEY_PREFIX","createPersistoid","config","blacklist","whitelist","transforms","throttle","storageKey","keyPrefix","undefined","key","storage","serialize","x","defaultSerialize","writeFailHandler","lastState","stagedState","keysToProcess","timeIterator","writePromise","update","state","Object","keys","forEach","passWhitelistBlacklist","indexOf","push","setInterval","processNextKey","length","clearInterval","shift","endState","reduce","subState","transformer","in","err","console","error","writeStagedState","setItem","catch","onWriteFail","process","env","NODE_ENV","flush","Promise","resolve","data","JSON","stringify"],"sources":["C:/Users/kyhh3/Desktop/redux-1-main (2)/node_modules/reduxjs-toolkit-persist/es/createPersistoid.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { KEY_PREFIX } from './constants';\nexport default function createPersistoid(config) {\n    // defaults\n    const blacklist = config.blacklist || null;\n    const whitelist = config.whitelist || null;\n    const transforms = config.transforms || [];\n    const throttle = config.throttle || 0;\n    const storageKey = `${config.keyPrefix !== undefined ? config.keyPrefix : KEY_PREFIX}${config.key}`;\n    const storage = config.storage;\n    let serialize;\n    if (config.serialize === false) {\n        serialize = (x) => x;\n    }\n    else if (typeof config.serialize === 'function') {\n        serialize = config.serialize;\n    }\n    else {\n        serialize = defaultSerialize;\n    }\n    const writeFailHandler = config.writeFailHandler || null;\n    // initialize stateful values\n    let lastState = {};\n    const stagedState = {};\n    const keysToProcess = [];\n    let timeIterator = null;\n    let writePromise = null;\n    const update = (state) => {\n        // add any changed keys to the queue\n        Object.keys(state).forEach(key => {\n            if (!passWhitelistBlacklist(key))\n                return; // is keyspace ignored? noop\n            if (lastState[key] === state[key])\n                return; // value unchanged? noop\n            if (keysToProcess.indexOf(key) !== -1)\n                return; // is key already queued? noop\n            keysToProcess.push(key); // add key to queue\n        });\n        //if any key is missing in the new state which was present in the lastState,\n        //add it for processing too\n        Object.keys(lastState).forEach(key => {\n            if (state[key] === undefined &&\n                passWhitelistBlacklist(key) &&\n                keysToProcess.indexOf(key) === -1 &&\n                lastState[key] !== undefined) {\n                keysToProcess.push(key);\n            }\n        });\n        // start the time iterator if not running (read: throttle)\n        if (timeIterator === null) {\n            timeIterator = setInterval(processNextKey, throttle);\n        }\n        lastState = state;\n    };\n    function processNextKey() {\n        if (keysToProcess.length === 0) {\n            if (timeIterator)\n                clearInterval(timeIterator);\n            timeIterator = null;\n            return;\n        }\n        const key = keysToProcess.shift();\n        if (key === undefined) {\n            return;\n        }\n        const endState = transforms.reduce((subState, transformer) => {\n            return transformer.in(subState, key, lastState);\n        }, lastState[key]);\n        if (endState !== undefined) {\n            try {\n                stagedState[key] = serialize(endState);\n            }\n            catch (err) {\n                console.error('reduxjs-toolkit-persist/createPersistoid: error serializing state', err);\n            }\n        }\n        else {\n            //if the endState is undefined, no need to persist the existing serialized content\n            delete stagedState[key];\n        }\n        if (keysToProcess.length === 0) {\n            writeStagedState();\n        }\n    }\n    function writeStagedState() {\n        // cleanup any removed keys just before write.\n        Object.keys(stagedState).forEach(key => {\n            if (lastState[key] === undefined) {\n                delete stagedState[key];\n            }\n        });\n        writePromise = storage\n            .setItem(storageKey, serialize(stagedState))\n            .catch(onWriteFail);\n    }\n    function passWhitelistBlacklist(key) {\n        if (whitelist && whitelist.indexOf(key) === -1 && key !== '_persist')\n            return false;\n        if (blacklist && blacklist.indexOf(key) !== -1)\n            return false;\n        return true;\n    }\n    function onWriteFail(err) {\n        // @TODO add fail handlers (typically storage full)\n        if (writeFailHandler)\n            writeFailHandler(err);\n        if (err && process.env.NODE_ENV !== 'production') {\n            console.error('Error storing data', err);\n        }\n    }\n    const flush = () => {\n        while (keysToProcess.length !== 0) {\n            processNextKey();\n        }\n        return writePromise || Promise.resolve();\n    };\n    // return `persistoid`\n    return {\n        update,\n        flush,\n    };\n}\n// @NOTE in the future this may be exposed via config\nfunction defaultSerialize(data) {\n    return JSON.stringify(data);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}