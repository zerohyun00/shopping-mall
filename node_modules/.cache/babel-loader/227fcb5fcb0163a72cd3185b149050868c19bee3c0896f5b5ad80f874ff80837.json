{"ast":null,"code":"import { createStore } from '@reduxjs/toolkit';\nimport { FLUSH, PAUSE, PERSIST, PURGE, REGISTER, REHYDRATE } from './constants';\nconst initialState = {\n  registry: [],\n  bootstrapped: false\n};\nconst persistorReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n  const firstIndex = state.registry.indexOf(action.key);\n  const registry = [...state.registry];\n  switch (action.type) {\n    case REGISTER:\n      return Object.assign(Object.assign({}, state), {\n        registry: [...state.registry, action.key]\n      });\n    case REHYDRATE:\n      registry.splice(firstIndex, 1);\n      return Object.assign(Object.assign({}, state), {\n        registry,\n        bootstrapped: registry.length === 0\n      });\n    default:\n      return state;\n  }\n};\nexport default function persistStore(store, options, cb) {\n  // help catch incorrect usage of passing PersistConfig in as PersistorOptions\n  if (process.env.NODE_ENV !== 'production') {\n    const optionsToTest = options || {};\n    const bannedKeys = ['blacklist', 'whitelist', 'transforms', 'storage', 'keyPrefix', 'migrate'];\n    bannedKeys.forEach(k => {\n      if (optionsToTest[k]) console.error(`reduxjs-toolkit-persist: invalid option passed to persistStore: \"${k}\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.`);\n    });\n  }\n  let boostrappedCb = cb || false;\n  const _pStore = createStore(persistorReducer, initialState, options && options.enhancer ? options.enhancer : undefined);\n  const register = key => {\n    _pStore.dispatch({\n      type: REGISTER,\n      key\n    });\n  };\n  const rehydrate = (key, payload, err) => {\n    const rehydrateAction = {\n      type: REHYDRATE,\n      payload,\n      err,\n      key\n    };\n    // dispatch to `store` to rehydrate and `persistor` to track result\n    store.dispatch(rehydrateAction);\n    _pStore.dispatch(rehydrateAction);\n    if (typeof boostrappedCb === \"function\" && persistor.getState().bootstrapped) {\n      boostrappedCb();\n      boostrappedCb = false;\n    }\n  };\n  const persistor = Object.assign(Object.assign({}, _pStore), {\n    purge: () => {\n      const results = [];\n      store.dispatch({\n        type: PURGE,\n        result: purgeResult => {\n          results.push(purgeResult);\n        }\n      });\n      return Promise.all(results);\n    },\n    flush: () => {\n      const results = [];\n      store.dispatch({\n        type: FLUSH,\n        result: flushResult => {\n          results.push(flushResult);\n        }\n      });\n      return Promise.all(results);\n    },\n    pause: () => {\n      store.dispatch({\n        type: PAUSE\n      });\n    },\n    persist: () => {\n      store.dispatch({\n        type: PERSIST,\n        register,\n        rehydrate\n      });\n    }\n  });\n  if (!(options && options.manualPersist)) {\n    persistor.persist();\n  }\n  return persistor;\n}","map":{"version":3,"names":["createStore","FLUSH","PAUSE","PERSIST","PURGE","REGISTER","REHYDRATE","initialState","registry","bootstrapped","persistorReducer","state","action","firstIndex","indexOf","key","type","Object","assign","splice","length","persistStore","store","options","cb","process","env","NODE_ENV","optionsToTest","bannedKeys","forEach","k","console","error","boostrappedCb","_pStore","enhancer","undefined","register","dispatch","rehydrate","payload","err","rehydrateAction","persistor","getState","purge","results","result","purgeResult","push","Promise","all","flush","flushResult","pause","persist","manualPersist"],"sources":["C:/Users/kyhh3/Desktop/redux-1-main (2)/node_modules/reduxjs-toolkit-persist/es/persistStore.js"],"sourcesContent":["import { createStore } from '@reduxjs/toolkit';\nimport { FLUSH, PAUSE, PERSIST, PURGE, REGISTER, REHYDRATE } from './constants';\nconst initialState = {\n    registry: [],\n    bootstrapped: false,\n};\nconst persistorReducer = (state = initialState, action) => {\n    const firstIndex = state.registry.indexOf(action.key);\n    const registry = [...state.registry];\n    switch (action.type) {\n        case REGISTER:\n            return Object.assign(Object.assign({}, state), { registry: [...state.registry, action.key] });\n        case REHYDRATE:\n            registry.splice(firstIndex, 1);\n            return Object.assign(Object.assign({}, state), { registry, bootstrapped: registry.length === 0 });\n        default:\n            return state;\n    }\n};\nexport default function persistStore(store, options, cb) {\n    // help catch incorrect usage of passing PersistConfig in as PersistorOptions\n    if (process.env.NODE_ENV !== 'production') {\n        const optionsToTest = options || {};\n        const bannedKeys = [\n            'blacklist',\n            'whitelist',\n            'transforms',\n            'storage',\n            'keyPrefix',\n            'migrate',\n        ];\n        bannedKeys.forEach(k => {\n            if (optionsToTest[k])\n                console.error(`reduxjs-toolkit-persist: invalid option passed to persistStore: \"${k}\". You may be incorrectly passing persistConfig into persistStore, whereas it should be passed into persistReducer.`);\n        });\n    }\n    let boostrappedCb = cb || false;\n    const _pStore = createStore(persistorReducer, initialState, options && options.enhancer ? options.enhancer : undefined);\n    const register = (key) => {\n        _pStore.dispatch({\n            type: REGISTER,\n            key,\n        });\n    };\n    const rehydrate = (key, payload, err) => {\n        const rehydrateAction = {\n            type: REHYDRATE,\n            payload,\n            err,\n            key,\n        };\n        // dispatch to `store` to rehydrate and `persistor` to track result\n        store.dispatch(rehydrateAction);\n        _pStore.dispatch(rehydrateAction);\n        if (typeof boostrappedCb === \"function\" && persistor.getState().bootstrapped) {\n            boostrappedCb();\n            boostrappedCb = false;\n        }\n    };\n    const persistor = Object.assign(Object.assign({}, _pStore), { purge: () => {\n            const results = [];\n            store.dispatch({\n                type: PURGE,\n                result: (purgeResult) => {\n                    results.push(purgeResult);\n                },\n            });\n            return Promise.all(results);\n        }, flush: () => {\n            const results = [];\n            store.dispatch({\n                type: FLUSH,\n                result: (flushResult) => {\n                    results.push(flushResult);\n                },\n            });\n            return Promise.all(results);\n        }, pause: () => {\n            store.dispatch({\n                type: PAUSE,\n            });\n        }, persist: () => {\n            store.dispatch({ type: PERSIST, register, rehydrate });\n        } });\n    if (!(options && options.manualPersist)) {\n        persistor.persist();\n    }\n    return persistor;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}